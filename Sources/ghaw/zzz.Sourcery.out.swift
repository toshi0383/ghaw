// Generated using Sourcery 0.13.1 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT


// Generated by using CoreCLI version 0.1.9

import CoreCLI

// - MARK: FindPullRequests.Argument

extension FindPullRequests.Argument {
    private typealias Base = FindPullRequests.Argument

    private static var autoMappedOptions: [PartialKeyPath<Base>: String] {
        return [
            \Base.match: "--match",
        ]
    }

    private static var autoMappedFlags: [KeyPath<Base, Bool>: String] {
        return [
:        ]
    }

    init(parser: ArgumentParserType) throws {

        func getOptionValue(keyPath: PartialKeyPath<Base>) throws -> String {
            if let short = Base.shortHandOptions[keyPath],
                let value = try? parser.getValue(forOption: "-\(short)") {
                return value
            }
            let long = Base.autoMappedOptions[keyPath]!
            return try parser.getValue(forOption: long)
        }

        func getFlag(keyPath: KeyPath<Base, Bool>) -> Bool {
            if let short = Base.shortHandFlags[keyPath] {
                let value = parser.getFlag("-\(short)")
                if value {
                    return true
                }
            }
            let long = Base.autoMappedFlags[keyPath]!
            return parser.getFlag(long)
        }

        func getCommandType() -> CommandType.Type? {
            for (i, arg) in parser.remainder.enumerated() {
                if let subCommand = Base.shortHandCommands[arg] {
                    parser.shift(at: i)
                    return subCommand
                }
                if let subCommand = Base.subCommands.first(where: { $0.name == arg }) {
                    parser.shift(at: i)
                    return subCommand
                }
            }

            return Base.defaultSubCommand
        }

        guard let shifted = parser.shift() else {
            throw CommandError("Missing match parameter.")
        }
        self.match = shifted
    }
}

// - MARK: Ghaw.Argument

extension Ghaw.Argument {
    private typealias Base = Ghaw.Argument

    private static var autoMappedOptions: [PartialKeyPath<Base>: String] {
        return [
:        ]
    }

    private static var autoMappedFlags: [KeyPath<Base, Bool>: String] {
        return [
            \Base.version: "--version",
        ]
    }

    init(parser: ArgumentParserType) throws {

        func getOptionValue(keyPath: PartialKeyPath<Base>) throws -> String {
            if let short = Base.shortHandOptions[keyPath],
                let value = try? parser.getValue(forOption: "-\(short)") {
                return value
            }
            let long = Base.autoMappedOptions[keyPath]!
            return try parser.getValue(forOption: long)
        }

        func getFlag(keyPath: KeyPath<Base, Bool>) -> Bool {
            if let short = Base.shortHandFlags[keyPath] {
                let value = parser.getFlag("-\(short)")
                if value {
                    return true
                }
            }
            let long = Base.autoMappedFlags[keyPath]!
            return parser.getFlag(long)
        }

        func getCommandType() -> CommandType.Type? {
            for (i, arg) in parser.remainder.enumerated() {
                if let subCommand = Base.shortHandCommands[arg] {
                    parser.shift(at: i)
                    return subCommand
                }
                if let subCommand = Base.subCommands.first(where: { $0.name == arg }) {
                    parser.shift(at: i)
                    return subCommand
                }
            }

            return Base.defaultSubCommand
        }

        self.version = getFlag(keyPath: \Base.version)
        if let type = getCommandType() {
            self.subCommand = try type.init(parser: parser)
        } else {
            self.subCommand = nil
        }
    }
}

// - MARK: JobDone.Argument

extension JobDone.Argument {
    private typealias Base = JobDone.Argument

    private static var autoMappedOptions: [PartialKeyPath<Base>: String] {
        return [
            \Base.user: "--user",
        ]
    }

    private static var autoMappedFlags: [KeyPath<Base, Bool>: String] {
        return [
            \Base.json: "--json",
        ]
    }

    init(parser: ArgumentParserType) throws {

        func getOptionValue(keyPath: PartialKeyPath<Base>) throws -> String {
            if let short = Base.shortHandOptions[keyPath],
                let value = try? parser.getValue(forOption: "-\(short)") {
                return value
            }
            let long = Base.autoMappedOptions[keyPath]!
            return try parser.getValue(forOption: long)
        }

        func getFlag(keyPath: KeyPath<Base, Bool>) -> Bool {
            if let short = Base.shortHandFlags[keyPath] {
                let value = parser.getFlag("-\(short)")
                if value {
                    return true
                }
            }
            let long = Base.autoMappedFlags[keyPath]!
            return parser.getFlag(long)
        }

        func getCommandType() -> CommandType.Type? {
            for (i, arg) in parser.remainder.enumerated() {
                if let subCommand = Base.shortHandCommands[arg] {
                    parser.shift(at: i)
                    return subCommand
                }
                if let subCommand = Base.subCommands.first(where: { $0.name == arg }) {
                    parser.shift(at: i)
                    return subCommand
                }
            }

            return Base.defaultSubCommand
        }

        self.json = getFlag(keyPath: \Base.json)
        self.user = try? getOptionValue(keyPath: \Base.user)
    }
}

// - MARK: ReadyForReview.Argument

extension ReadyForReview.Argument {
    private typealias Base = ReadyForReview.Argument

    private static var autoMappedOptions: [PartialKeyPath<Base>: String] {
        return [
            \Base.user: "--user",
        ]
    }

    private static var autoMappedFlags: [KeyPath<Base, Bool>: String] {
        return [
            \Base.json: "--json",
        ]
    }

    init(parser: ArgumentParserType) throws {

        func getOptionValue(keyPath: PartialKeyPath<Base>) throws -> String {
            if let short = Base.shortHandOptions[keyPath],
                let value = try? parser.getValue(forOption: "-\(short)") {
                return value
            }
            let long = Base.autoMappedOptions[keyPath]!
            return try parser.getValue(forOption: long)
        }

        func getFlag(keyPath: KeyPath<Base, Bool>) -> Bool {
            if let short = Base.shortHandFlags[keyPath] {
                let value = parser.getFlag("-\(short)")
                if value {
                    return true
                }
            }
            let long = Base.autoMappedFlags[keyPath]!
            return parser.getFlag(long)
        }

        func getCommandType() -> CommandType.Type? {
            for (i, arg) in parser.remainder.enumerated() {
                if let subCommand = Base.shortHandCommands[arg] {
                    parser.shift(at: i)
                    return subCommand
                }
                if let subCommand = Base.subCommands.first(where: { $0.name == arg }) {
                    parser.shift(at: i)
                    return subCommand
                }
            }

            return Base.defaultSubCommand
        }

        self.json = getFlag(keyPath: \Base.json)
        self.user = try? getOptionValue(keyPath: \Base.user)
    }
}

// - MARK: FindPullRequests

extension FindPullRequests {
    private typealias Base = FindPullRequests

    init(parser: ArgumentParserType) throws {
        self.argument = try FindPullRequests.Argument(parser: parser)
    }

    static var name: String {
        return "find-pull-requests"
    }
}

// - MARK: Ghaw

extension Ghaw {
    private typealias Base = Ghaw

    init(parser: ArgumentParserType) throws {
        self.argument = try Ghaw.Argument(parser: parser)
    }

    static var name: String {
        return "ghaw"
    }
}

// - MARK: JobDone

extension JobDone {
    private typealias Base = JobDone

    init(parser: ArgumentParserType) throws {
        self.argument = try JobDone.Argument(parser: parser)
    }

    static var name: String {
        return "job-done"
    }
}

// - MARK: ReadyForReview

extension ReadyForReview {
    private typealias Base = ReadyForReview

    init(parser: ArgumentParserType) throws {
        self.argument = try ReadyForReview.Argument(parser: parser)
    }

    static var name: String {
        return "ready-for-review"
    }
}

